// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bingo.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_bingo_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_bingo_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_bingo_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_bingo_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_bingo_2eproto;
namespace bingo {
class CheckBingoRequest;
struct CheckBingoRequestDefaultTypeInternal;
extern CheckBingoRequestDefaultTypeInternal _CheckBingoRequest_default_instance_;
class CheckBingoResponse;
struct CheckBingoResponseDefaultTypeInternal;
extern CheckBingoResponseDefaultTypeInternal _CheckBingoResponse_default_instance_;
class CreateGameRequest;
struct CreateGameRequestDefaultTypeInternal;
extern CreateGameRequestDefaultTypeInternal _CreateGameRequest_default_instance_;
class CreateGameResponse;
struct CreateGameResponseDefaultTypeInternal;
extern CreateGameResponseDefaultTypeInternal _CreateGameResponse_default_instance_;
class DrawNumberRequest;
struct DrawNumberRequestDefaultTypeInternal;
extern DrawNumberRequestDefaultTypeInternal _DrawNumberRequest_default_instance_;
class DrawNumberResponse;
struct DrawNumberResponseDefaultTypeInternal;
extern DrawNumberResponseDefaultTypeInternal _DrawNumberResponse_default_instance_;
class GetCardRequest;
struct GetCardRequestDefaultTypeInternal;
extern GetCardRequestDefaultTypeInternal _GetCardRequest_default_instance_;
class GetCardResponse;
struct GetCardResponseDefaultTypeInternal;
extern GetCardResponseDefaultTypeInternal _GetCardResponse_default_instance_;
class MarkNumberRequest;
struct MarkNumberRequestDefaultTypeInternal;
extern MarkNumberRequestDefaultTypeInternal _MarkNumberRequest_default_instance_;
class MarkNumberResponse;
struct MarkNumberResponseDefaultTypeInternal;
extern MarkNumberResponseDefaultTypeInternal _MarkNumberResponse_default_instance_;
class RegisterCardRequest;
struct RegisterCardRequestDefaultTypeInternal;
extern RegisterCardRequestDefaultTypeInternal _RegisterCardRequest_default_instance_;
class RegisterCardResponse;
struct RegisterCardResponseDefaultTypeInternal;
extern RegisterCardResponseDefaultTypeInternal _RegisterCardResponse_default_instance_;
class RegisterPlayerRequest;
struct RegisterPlayerRequestDefaultTypeInternal;
extern RegisterPlayerRequestDefaultTypeInternal _RegisterPlayerRequest_default_instance_;
class RegisterPlayerResponse;
struct RegisterPlayerResponseDefaultTypeInternal;
extern RegisterPlayerResponseDefaultTypeInternal _RegisterPlayerResponse_default_instance_;
class ValidateBingoRequest;
struct ValidateBingoRequestDefaultTypeInternal;
extern ValidateBingoRequestDefaultTypeInternal _ValidateBingoRequest_default_instance_;
class ValidateBingoResponse;
struct ValidateBingoResponseDefaultTypeInternal;
extern ValidateBingoResponseDefaultTypeInternal _ValidateBingoResponse_default_instance_;
class ValidateNumberRequest;
struct ValidateNumberRequestDefaultTypeInternal;
extern ValidateNumberRequestDefaultTypeInternal _ValidateNumberRequest_default_instance_;
class ValidateNumberResponse;
struct ValidateNumberResponseDefaultTypeInternal;
extern ValidateNumberResponseDefaultTypeInternal _ValidateNumberResponse_default_instance_;
}  // namespace bingo
PROTOBUF_NAMESPACE_OPEN
template<> ::bingo::CheckBingoRequest* Arena::CreateMaybeMessage<::bingo::CheckBingoRequest>(Arena*);
template<> ::bingo::CheckBingoResponse* Arena::CreateMaybeMessage<::bingo::CheckBingoResponse>(Arena*);
template<> ::bingo::CreateGameRequest* Arena::CreateMaybeMessage<::bingo::CreateGameRequest>(Arena*);
template<> ::bingo::CreateGameResponse* Arena::CreateMaybeMessage<::bingo::CreateGameResponse>(Arena*);
template<> ::bingo::DrawNumberRequest* Arena::CreateMaybeMessage<::bingo::DrawNumberRequest>(Arena*);
template<> ::bingo::DrawNumberResponse* Arena::CreateMaybeMessage<::bingo::DrawNumberResponse>(Arena*);
template<> ::bingo::GetCardRequest* Arena::CreateMaybeMessage<::bingo::GetCardRequest>(Arena*);
template<> ::bingo::GetCardResponse* Arena::CreateMaybeMessage<::bingo::GetCardResponse>(Arena*);
template<> ::bingo::MarkNumberRequest* Arena::CreateMaybeMessage<::bingo::MarkNumberRequest>(Arena*);
template<> ::bingo::MarkNumberResponse* Arena::CreateMaybeMessage<::bingo::MarkNumberResponse>(Arena*);
template<> ::bingo::RegisterCardRequest* Arena::CreateMaybeMessage<::bingo::RegisterCardRequest>(Arena*);
template<> ::bingo::RegisterCardResponse* Arena::CreateMaybeMessage<::bingo::RegisterCardResponse>(Arena*);
template<> ::bingo::RegisterPlayerRequest* Arena::CreateMaybeMessage<::bingo::RegisterPlayerRequest>(Arena*);
template<> ::bingo::RegisterPlayerResponse* Arena::CreateMaybeMessage<::bingo::RegisterPlayerResponse>(Arena*);
template<> ::bingo::ValidateBingoRequest* Arena::CreateMaybeMessage<::bingo::ValidateBingoRequest>(Arena*);
template<> ::bingo::ValidateBingoResponse* Arena::CreateMaybeMessage<::bingo::ValidateBingoResponse>(Arena*);
template<> ::bingo::ValidateNumberRequest* Arena::CreateMaybeMessage<::bingo::ValidateNumberRequest>(Arena*);
template<> ::bingo::ValidateNumberResponse* Arena::CreateMaybeMessage<::bingo::ValidateNumberResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace bingo {

// ===================================================================

class CreateGameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.CreateGameRequest) */ {
 public:
  inline CreateGameRequest() : CreateGameRequest(nullptr) {}
  ~CreateGameRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateGameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateGameRequest(const CreateGameRequest& from);
  CreateGameRequest(CreateGameRequest&& from) noexcept
    : CreateGameRequest() {
    *this = ::std::move(from);
  }

  inline CreateGameRequest& operator=(const CreateGameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGameRequest& operator=(CreateGameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateGameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateGameRequest* internal_default_instance() {
    return reinterpret_cast<const CreateGameRequest*>(
               &_CreateGameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateGameRequest& a, CreateGameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateGameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateGameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateGameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateGameRequest& from) {
    CreateGameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.CreateGameRequest";
  }
  protected:
  explicit CreateGameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameNameFieldNumber = 1,
  };
  // string game_name = 1;
  void clear_game_name();
  const std::string& game_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_name();
  PROTOBUF_NODISCARD std::string* release_game_name();
  void set_allocated_game_name(std::string* game_name);
  private:
  const std::string& _internal_game_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_name(const std::string& value);
  std::string* _internal_mutable_game_name();
  public:

  // @@protoc_insertion_point(class_scope:bingo.CreateGameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class CreateGameResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.CreateGameResponse) */ {
 public:
  inline CreateGameResponse() : CreateGameResponse(nullptr) {}
  ~CreateGameResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateGameResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateGameResponse(const CreateGameResponse& from);
  CreateGameResponse(CreateGameResponse&& from) noexcept
    : CreateGameResponse() {
    *this = ::std::move(from);
  }

  inline CreateGameResponse& operator=(const CreateGameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGameResponse& operator=(CreateGameResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateGameResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateGameResponse* internal_default_instance() {
    return reinterpret_cast<const CreateGameResponse*>(
               &_CreateGameResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateGameResponse& a, CreateGameResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGameResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGameResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateGameResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateGameResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateGameResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateGameResponse& from) {
    CreateGameResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGameResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.CreateGameResponse";
  }
  protected:
  explicit CreateGameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
  };
  // string game_id = 1;
  void clear_game_id();
  const std::string& game_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_id();
  PROTOBUF_NODISCARD std::string* release_game_id();
  void set_allocated_game_id(std::string* game_id);
  private:
  const std::string& _internal_game_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_id(const std::string& value);
  std::string* _internal_mutable_game_id();
  public:

  // @@protoc_insertion_point(class_scope:bingo.CreateGameResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class RegisterPlayerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.RegisterPlayerRequest) */ {
 public:
  inline RegisterPlayerRequest() : RegisterPlayerRequest(nullptr) {}
  ~RegisterPlayerRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterPlayerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterPlayerRequest(const RegisterPlayerRequest& from);
  RegisterPlayerRequest(RegisterPlayerRequest&& from) noexcept
    : RegisterPlayerRequest() {
    *this = ::std::move(from);
  }

  inline RegisterPlayerRequest& operator=(const RegisterPlayerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterPlayerRequest& operator=(RegisterPlayerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterPlayerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterPlayerRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterPlayerRequest*>(
               &_RegisterPlayerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegisterPlayerRequest& a, RegisterPlayerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterPlayerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterPlayerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterPlayerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterPlayerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterPlayerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterPlayerRequest& from) {
    RegisterPlayerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterPlayerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.RegisterPlayerRequest";
  }
  protected:
  explicit RegisterPlayerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerNameFieldNumber = 2,
  };
  // string game_id = 1;
  void clear_game_id();
  const std::string& game_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_id();
  PROTOBUF_NODISCARD std::string* release_game_id();
  void set_allocated_game_id(std::string* game_id);
  private:
  const std::string& _internal_game_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_id(const std::string& value);
  std::string* _internal_mutable_game_id();
  public:

  // string player_name = 2;
  void clear_player_name();
  const std::string& player_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_name();
  PROTOBUF_NODISCARD std::string* release_player_name();
  void set_allocated_player_name(std::string* player_name);
  private:
  const std::string& _internal_player_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_name(const std::string& value);
  std::string* _internal_mutable_player_name();
  public:

  // @@protoc_insertion_point(class_scope:bingo.RegisterPlayerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class RegisterPlayerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.RegisterPlayerResponse) */ {
 public:
  inline RegisterPlayerResponse() : RegisterPlayerResponse(nullptr) {}
  ~RegisterPlayerResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterPlayerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterPlayerResponse(const RegisterPlayerResponse& from);
  RegisterPlayerResponse(RegisterPlayerResponse&& from) noexcept
    : RegisterPlayerResponse() {
    *this = ::std::move(from);
  }

  inline RegisterPlayerResponse& operator=(const RegisterPlayerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterPlayerResponse& operator=(RegisterPlayerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterPlayerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterPlayerResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterPlayerResponse*>(
               &_RegisterPlayerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RegisterPlayerResponse& a, RegisterPlayerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterPlayerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterPlayerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterPlayerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterPlayerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterPlayerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterPlayerResponse& from) {
    RegisterPlayerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterPlayerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.RegisterPlayerResponse";
  }
  protected:
  explicit RegisterPlayerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardNumbersFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
    kSuccessFieldNumber = 3,
  };
  // repeated int32 card_numbers = 2;
  int card_numbers_size() const;
  private:
  int _internal_card_numbers_size() const;
  public:
  void clear_card_numbers();
  private:
  int32_t _internal_card_numbers(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_card_numbers() const;
  void _internal_add_card_numbers(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_card_numbers();
  public:
  int32_t card_numbers(int index) const;
  void set_card_numbers(int index, int32_t value);
  void add_card_numbers(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      card_numbers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_card_numbers();

  // string player_id = 1;
  void clear_player_id();
  const std::string& player_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* player_id);
  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const std::string& value);
  std::string* _internal_mutable_player_id();
  public:

  // bool success = 3;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bingo.RegisterPlayerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > card_numbers_;
    mutable std::atomic<int> _card_numbers_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_id_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class DrawNumberRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.DrawNumberRequest) */ {
 public:
  inline DrawNumberRequest() : DrawNumberRequest(nullptr) {}
  ~DrawNumberRequest() override;
  explicit PROTOBUF_CONSTEXPR DrawNumberRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawNumberRequest(const DrawNumberRequest& from);
  DrawNumberRequest(DrawNumberRequest&& from) noexcept
    : DrawNumberRequest() {
    *this = ::std::move(from);
  }

  inline DrawNumberRequest& operator=(const DrawNumberRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawNumberRequest& operator=(DrawNumberRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawNumberRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawNumberRequest* internal_default_instance() {
    return reinterpret_cast<const DrawNumberRequest*>(
               &_DrawNumberRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DrawNumberRequest& a, DrawNumberRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawNumberRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawNumberRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawNumberRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawNumberRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawNumberRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawNumberRequest& from) {
    DrawNumberRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawNumberRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.DrawNumberRequest";
  }
  protected:
  explicit DrawNumberRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
  };
  // string game_id = 1;
  void clear_game_id();
  const std::string& game_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_id();
  PROTOBUF_NODISCARD std::string* release_game_id();
  void set_allocated_game_id(std::string* game_id);
  private:
  const std::string& _internal_game_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_id(const std::string& value);
  std::string* _internal_mutable_game_id();
  public:

  // @@protoc_insertion_point(class_scope:bingo.DrawNumberRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class DrawNumberResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.DrawNumberResponse) */ {
 public:
  inline DrawNumberResponse() : DrawNumberResponse(nullptr) {}
  ~DrawNumberResponse() override;
  explicit PROTOBUF_CONSTEXPR DrawNumberResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawNumberResponse(const DrawNumberResponse& from);
  DrawNumberResponse(DrawNumberResponse&& from) noexcept
    : DrawNumberResponse() {
    *this = ::std::move(from);
  }

  inline DrawNumberResponse& operator=(const DrawNumberResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawNumberResponse& operator=(DrawNumberResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawNumberResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawNumberResponse* internal_default_instance() {
    return reinterpret_cast<const DrawNumberResponse*>(
               &_DrawNumberResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DrawNumberResponse& a, DrawNumberResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawNumberResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawNumberResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawNumberResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawNumberResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawNumberResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawNumberResponse& from) {
    DrawNumberResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawNumberResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.DrawNumberResponse";
  }
  protected:
  explicit DrawNumberResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // int32 number = 1;
  void clear_number();
  int32_t number() const;
  void set_number(int32_t value);
  private:
  int32_t _internal_number() const;
  void _internal_set_number(int32_t value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bingo.DrawNumberResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t number_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class MarkNumberRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.MarkNumberRequest) */ {
 public:
  inline MarkNumberRequest() : MarkNumberRequest(nullptr) {}
  ~MarkNumberRequest() override;
  explicit PROTOBUF_CONSTEXPR MarkNumberRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkNumberRequest(const MarkNumberRequest& from);
  MarkNumberRequest(MarkNumberRequest&& from) noexcept
    : MarkNumberRequest() {
    *this = ::std::move(from);
  }

  inline MarkNumberRequest& operator=(const MarkNumberRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkNumberRequest& operator=(MarkNumberRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkNumberRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkNumberRequest* internal_default_instance() {
    return reinterpret_cast<const MarkNumberRequest*>(
               &_MarkNumberRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MarkNumberRequest& a, MarkNumberRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkNumberRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkNumberRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkNumberRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkNumberRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarkNumberRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarkNumberRequest& from) {
    MarkNumberRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkNumberRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.MarkNumberRequest";
  }
  protected:
  explicit MarkNumberRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
    kNumberFieldNumber = 3,
  };
  // string game_id = 1;
  void clear_game_id();
  const std::string& game_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_id();
  PROTOBUF_NODISCARD std::string* release_game_id();
  void set_allocated_game_id(std::string* game_id);
  private:
  const std::string& _internal_game_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_id(const std::string& value);
  std::string* _internal_mutable_game_id();
  public:

  // string player_id = 2;
  void clear_player_id();
  const std::string& player_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* player_id);
  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const std::string& value);
  std::string* _internal_mutable_player_id();
  public:

  // int32 number = 3;
  void clear_number();
  int32_t number() const;
  void set_number(int32_t value);
  private:
  int32_t _internal_number() const;
  void _internal_set_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bingo.MarkNumberRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_id_;
    int32_t number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class MarkNumberResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.MarkNumberResponse) */ {
 public:
  inline MarkNumberResponse() : MarkNumberResponse(nullptr) {}
  ~MarkNumberResponse() override;
  explicit PROTOBUF_CONSTEXPR MarkNumberResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkNumberResponse(const MarkNumberResponse& from);
  MarkNumberResponse(MarkNumberResponse&& from) noexcept
    : MarkNumberResponse() {
    *this = ::std::move(from);
  }

  inline MarkNumberResponse& operator=(const MarkNumberResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkNumberResponse& operator=(MarkNumberResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MarkNumberResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkNumberResponse* internal_default_instance() {
    return reinterpret_cast<const MarkNumberResponse*>(
               &_MarkNumberResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MarkNumberResponse& a, MarkNumberResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkNumberResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkNumberResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkNumberResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkNumberResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MarkNumberResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MarkNumberResponse& from) {
    MarkNumberResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkNumberResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.MarkNumberResponse";
  }
  protected:
  explicit MarkNumberResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bingo.MarkNumberResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class CheckBingoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.CheckBingoRequest) */ {
 public:
  inline CheckBingoRequest() : CheckBingoRequest(nullptr) {}
  ~CheckBingoRequest() override;
  explicit PROTOBUF_CONSTEXPR CheckBingoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckBingoRequest(const CheckBingoRequest& from);
  CheckBingoRequest(CheckBingoRequest&& from) noexcept
    : CheckBingoRequest() {
    *this = ::std::move(from);
  }

  inline CheckBingoRequest& operator=(const CheckBingoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckBingoRequest& operator=(CheckBingoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckBingoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckBingoRequest* internal_default_instance() {
    return reinterpret_cast<const CheckBingoRequest*>(
               &_CheckBingoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CheckBingoRequest& a, CheckBingoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckBingoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckBingoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckBingoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckBingoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckBingoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckBingoRequest& from) {
    CheckBingoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckBingoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.CheckBingoRequest";
  }
  protected:
  explicit CheckBingoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kPlayerIdFieldNumber = 2,
  };
  // string game_id = 1;
  void clear_game_id();
  const std::string& game_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_id();
  PROTOBUF_NODISCARD std::string* release_game_id();
  void set_allocated_game_id(std::string* game_id);
  private:
  const std::string& _internal_game_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_id(const std::string& value);
  std::string* _internal_mutable_game_id();
  public:

  // string player_id = 2;
  void clear_player_id();
  const std::string& player_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* player_id);
  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const std::string& value);
  std::string* _internal_mutable_player_id();
  public:

  // @@protoc_insertion_point(class_scope:bingo.CheckBingoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class CheckBingoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.CheckBingoResponse) */ {
 public:
  inline CheckBingoResponse() : CheckBingoResponse(nullptr) {}
  ~CheckBingoResponse() override;
  explicit PROTOBUF_CONSTEXPR CheckBingoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckBingoResponse(const CheckBingoResponse& from);
  CheckBingoResponse(CheckBingoResponse&& from) noexcept
    : CheckBingoResponse() {
    *this = ::std::move(from);
  }

  inline CheckBingoResponse& operator=(const CheckBingoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckBingoResponse& operator=(CheckBingoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckBingoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CheckBingoResponse* internal_default_instance() {
    return reinterpret_cast<const CheckBingoResponse*>(
               &_CheckBingoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CheckBingoResponse& a, CheckBingoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckBingoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckBingoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckBingoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckBingoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckBingoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckBingoResponse& from) {
    CheckBingoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckBingoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.CheckBingoResponse";
  }
  protected:
  explicit CheckBingoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBingoFieldNumber = 1,
  };
  // bool bingo = 1;
  void clear_bingo();
  bool bingo() const;
  void set_bingo(bool value);
  private:
  bool _internal_bingo() const;
  void _internal_set_bingo(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bingo.CheckBingoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool bingo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class ValidateNumberRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.ValidateNumberRequest) */ {
 public:
  inline ValidateNumberRequest() : ValidateNumberRequest(nullptr) {}
  ~ValidateNumberRequest() override;
  explicit PROTOBUF_CONSTEXPR ValidateNumberRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateNumberRequest(const ValidateNumberRequest& from);
  ValidateNumberRequest(ValidateNumberRequest&& from) noexcept
    : ValidateNumberRequest() {
    *this = ::std::move(from);
  }

  inline ValidateNumberRequest& operator=(const ValidateNumberRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateNumberRequest& operator=(ValidateNumberRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateNumberRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateNumberRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateNumberRequest*>(
               &_ValidateNumberRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ValidateNumberRequest& a, ValidateNumberRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateNumberRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateNumberRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateNumberRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateNumberRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateNumberRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidateNumberRequest& from) {
    ValidateNumberRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateNumberRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.ValidateNumberRequest";
  }
  protected:
  explicit ValidateNumberRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kNumberFieldNumber = 2,
  };
  // string player_id = 1;
  void clear_player_id();
  const std::string& player_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* player_id);
  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const std::string& value);
  std::string* _internal_mutable_player_id();
  public:

  // int32 number = 2;
  void clear_number();
  int32_t number() const;
  void set_number(int32_t value);
  private:
  int32_t _internal_number() const;
  void _internal_set_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:bingo.ValidateNumberRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_id_;
    int32_t number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class ValidateNumberResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.ValidateNumberResponse) */ {
 public:
  inline ValidateNumberResponse() : ValidateNumberResponse(nullptr) {}
  ~ValidateNumberResponse() override;
  explicit PROTOBUF_CONSTEXPR ValidateNumberResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateNumberResponse(const ValidateNumberResponse& from);
  ValidateNumberResponse(ValidateNumberResponse&& from) noexcept
    : ValidateNumberResponse() {
    *this = ::std::move(from);
  }

  inline ValidateNumberResponse& operator=(const ValidateNumberResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateNumberResponse& operator=(ValidateNumberResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateNumberResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateNumberResponse* internal_default_instance() {
    return reinterpret_cast<const ValidateNumberResponse*>(
               &_ValidateNumberResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ValidateNumberResponse& a, ValidateNumberResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateNumberResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateNumberResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateNumberResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateNumberResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateNumberResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidateNumberResponse& from) {
    ValidateNumberResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateNumberResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.ValidateNumberResponse";
  }
  protected:
  explicit ValidateNumberResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bingo.ValidateNumberResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class ValidateBingoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.ValidateBingoRequest) */ {
 public:
  inline ValidateBingoRequest() : ValidateBingoRequest(nullptr) {}
  ~ValidateBingoRequest() override;
  explicit PROTOBUF_CONSTEXPR ValidateBingoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateBingoRequest(const ValidateBingoRequest& from);
  ValidateBingoRequest(ValidateBingoRequest&& from) noexcept
    : ValidateBingoRequest() {
    *this = ::std::move(from);
  }

  inline ValidateBingoRequest& operator=(const ValidateBingoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateBingoRequest& operator=(ValidateBingoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateBingoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateBingoRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateBingoRequest*>(
               &_ValidateBingoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ValidateBingoRequest& a, ValidateBingoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateBingoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateBingoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateBingoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateBingoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateBingoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidateBingoRequest& from) {
    ValidateBingoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateBingoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.ValidateBingoRequest";
  }
  protected:
  explicit ValidateBingoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumbersFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // repeated int32 numbers = 2;
  int numbers_size() const;
  private:
  int _internal_numbers_size() const;
  public:
  void clear_numbers();
  private:
  int32_t _internal_numbers(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_numbers() const;
  void _internal_add_numbers(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_numbers();
  public:
  int32_t numbers(int index) const;
  void set_numbers(int index, int32_t value);
  void add_numbers(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      numbers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_numbers();

  // string player_id = 1;
  void clear_player_id();
  const std::string& player_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* player_id);
  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const std::string& value);
  std::string* _internal_mutable_player_id();
  public:

  // @@protoc_insertion_point(class_scope:bingo.ValidateBingoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > numbers_;
    mutable std::atomic<int> _numbers_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class ValidateBingoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.ValidateBingoResponse) */ {
 public:
  inline ValidateBingoResponse() : ValidateBingoResponse(nullptr) {}
  ~ValidateBingoResponse() override;
  explicit PROTOBUF_CONSTEXPR ValidateBingoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateBingoResponse(const ValidateBingoResponse& from);
  ValidateBingoResponse(ValidateBingoResponse&& from) noexcept
    : ValidateBingoResponse() {
    *this = ::std::move(from);
  }

  inline ValidateBingoResponse& operator=(const ValidateBingoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateBingoResponse& operator=(ValidateBingoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateBingoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateBingoResponse* internal_default_instance() {
    return reinterpret_cast<const ValidateBingoResponse*>(
               &_ValidateBingoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ValidateBingoResponse& a, ValidateBingoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateBingoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateBingoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateBingoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateBingoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateBingoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ValidateBingoResponse& from) {
    ValidateBingoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateBingoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.ValidateBingoResponse";
  }
  protected:
  explicit ValidateBingoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBingoFieldNumber = 1,
  };
  // bool bingo = 1;
  void clear_bingo();
  bool bingo() const;
  void set_bingo(bool value);
  private:
  bool _internal_bingo() const;
  void _internal_set_bingo(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bingo.ValidateBingoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool bingo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class GetCardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.GetCardRequest) */ {
 public:
  inline GetCardRequest() : GetCardRequest(nullptr) {}
  ~GetCardRequest() override;
  explicit PROTOBUF_CONSTEXPR GetCardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCardRequest(const GetCardRequest& from);
  GetCardRequest(GetCardRequest&& from) noexcept
    : GetCardRequest() {
    *this = ::std::move(from);
  }

  inline GetCardRequest& operator=(const GetCardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCardRequest& operator=(GetCardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCardRequest* internal_default_instance() {
    return reinterpret_cast<const GetCardRequest*>(
               &_GetCardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetCardRequest& a, GetCardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCardRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCardRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCardRequest& from) {
    GetCardRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCardRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.GetCardRequest";
  }
  protected:
  explicit GetCardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
  };
  // string player_id = 1;
  void clear_player_id();
  const std::string& player_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* player_id);
  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const std::string& value);
  std::string* _internal_mutable_player_id();
  public:

  // @@protoc_insertion_point(class_scope:bingo.GetCardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class GetCardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.GetCardResponse) */ {
 public:
  inline GetCardResponse() : GetCardResponse(nullptr) {}
  ~GetCardResponse() override;
  explicit PROTOBUF_CONSTEXPR GetCardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCardResponse(const GetCardResponse& from);
  GetCardResponse(GetCardResponse&& from) noexcept
    : GetCardResponse() {
    *this = ::std::move(from);
  }

  inline GetCardResponse& operator=(const GetCardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCardResponse& operator=(GetCardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCardResponse* internal_default_instance() {
    return reinterpret_cast<const GetCardResponse*>(
               &_GetCardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetCardResponse& a, GetCardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCardResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCardResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetCardResponse& from) {
    GetCardResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCardResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.GetCardResponse";
  }
  protected:
  explicit GetCardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardNumbersFieldNumber = 1,
  };
  // repeated int32 card_numbers = 1;
  int card_numbers_size() const;
  private:
  int _internal_card_numbers_size() const;
  public:
  void clear_card_numbers();
  private:
  int32_t _internal_card_numbers(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_card_numbers() const;
  void _internal_add_card_numbers(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_card_numbers();
  public:
  int32_t card_numbers(int index) const;
  void set_card_numbers(int index, int32_t value);
  void add_card_numbers(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      card_numbers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_card_numbers();

  // @@protoc_insertion_point(class_scope:bingo.GetCardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > card_numbers_;
    mutable std::atomic<int> _card_numbers_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class RegisterCardRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.RegisterCardRequest) */ {
 public:
  inline RegisterCardRequest() : RegisterCardRequest(nullptr) {}
  ~RegisterCardRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterCardRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterCardRequest(const RegisterCardRequest& from);
  RegisterCardRequest(RegisterCardRequest&& from) noexcept
    : RegisterCardRequest() {
    *this = ::std::move(from);
  }

  inline RegisterCardRequest& operator=(const RegisterCardRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterCardRequest& operator=(RegisterCardRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterCardRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterCardRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterCardRequest*>(
               &_RegisterCardRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RegisterCardRequest& a, RegisterCardRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterCardRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterCardRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterCardRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterCardRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterCardRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterCardRequest& from) {
    RegisterCardRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterCardRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.RegisterCardRequest";
  }
  protected:
  explicit RegisterCardRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCardNumbersFieldNumber = 2,
    kPlayerIdFieldNumber = 1,
  };
  // repeated int32 card_numbers = 2;
  int card_numbers_size() const;
  private:
  int _internal_card_numbers_size() const;
  public:
  void clear_card_numbers();
  private:
  int32_t _internal_card_numbers(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_card_numbers() const;
  void _internal_add_card_numbers(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_card_numbers();
  public:
  int32_t card_numbers(int index) const;
  void set_card_numbers(int index, int32_t value);
  void add_card_numbers(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      card_numbers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_card_numbers();

  // string player_id = 1;
  void clear_player_id();
  const std::string& player_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_id();
  PROTOBUF_NODISCARD std::string* release_player_id();
  void set_allocated_player_id(std::string* player_id);
  private:
  const std::string& _internal_player_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_id(const std::string& value);
  std::string* _internal_mutable_player_id();
  public:

  // @@protoc_insertion_point(class_scope:bingo.RegisterCardRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > card_numbers_;
    mutable std::atomic<int> _card_numbers_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// -------------------------------------------------------------------

class RegisterCardResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:bingo.RegisterCardResponse) */ {
 public:
  inline RegisterCardResponse() : RegisterCardResponse(nullptr) {}
  ~RegisterCardResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterCardResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterCardResponse(const RegisterCardResponse& from);
  RegisterCardResponse(RegisterCardResponse&& from) noexcept
    : RegisterCardResponse() {
    *this = ::std::move(from);
  }

  inline RegisterCardResponse& operator=(const RegisterCardResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterCardResponse& operator=(RegisterCardResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterCardResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterCardResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterCardResponse*>(
               &_RegisterCardResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RegisterCardResponse& a, RegisterCardResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterCardResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterCardResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterCardResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterCardResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterCardResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterCardResponse& from) {
    RegisterCardResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterCardResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "bingo.RegisterCardResponse";
  }
  protected:
  explicit RegisterCardResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSuccessFieldNumber = 1,
  };
  // bool success = 1;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:bingo.RegisterCardResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_bingo_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateGameRequest

// string game_name = 1;
inline void CreateGameRequest::clear_game_name() {
  _impl_.game_name_.ClearToEmpty();
}
inline const std::string& CreateGameRequest::game_name() const {
  // @@protoc_insertion_point(field_get:bingo.CreateGameRequest.game_name)
  return _internal_game_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateGameRequest::set_game_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.game_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.CreateGameRequest.game_name)
}
inline std::string* CreateGameRequest::mutable_game_name() {
  std::string* _s = _internal_mutable_game_name();
  // @@protoc_insertion_point(field_mutable:bingo.CreateGameRequest.game_name)
  return _s;
}
inline const std::string& CreateGameRequest::_internal_game_name() const {
  return _impl_.game_name_.Get();
}
inline void CreateGameRequest::_internal_set_game_name(const std::string& value) {
  
  _impl_.game_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateGameRequest::_internal_mutable_game_name() {
  
  return _impl_.game_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateGameRequest::release_game_name() {
  // @@protoc_insertion_point(field_release:bingo.CreateGameRequest.game_name)
  return _impl_.game_name_.Release();
}
inline void CreateGameRequest::set_allocated_game_name(std::string* game_name) {
  if (game_name != nullptr) {
    
  } else {
    
  }
  _impl_.game_name_.SetAllocated(game_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_name_.IsDefault()) {
    _impl_.game_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.CreateGameRequest.game_name)
}

// -------------------------------------------------------------------

// CreateGameResponse

// string game_id = 1;
inline void CreateGameResponse::clear_game_id() {
  _impl_.game_id_.ClearToEmpty();
}
inline const std::string& CreateGameResponse::game_id() const {
  // @@protoc_insertion_point(field_get:bingo.CreateGameResponse.game_id)
  return _internal_game_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateGameResponse::set_game_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.game_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.CreateGameResponse.game_id)
}
inline std::string* CreateGameResponse::mutable_game_id() {
  std::string* _s = _internal_mutable_game_id();
  // @@protoc_insertion_point(field_mutable:bingo.CreateGameResponse.game_id)
  return _s;
}
inline const std::string& CreateGameResponse::_internal_game_id() const {
  return _impl_.game_id_.Get();
}
inline void CreateGameResponse::_internal_set_game_id(const std::string& value) {
  
  _impl_.game_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateGameResponse::_internal_mutable_game_id() {
  
  return _impl_.game_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateGameResponse::release_game_id() {
  // @@protoc_insertion_point(field_release:bingo.CreateGameResponse.game_id)
  return _impl_.game_id_.Release();
}
inline void CreateGameResponse::set_allocated_game_id(std::string* game_id) {
  if (game_id != nullptr) {
    
  } else {
    
  }
  _impl_.game_id_.SetAllocated(game_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_id_.IsDefault()) {
    _impl_.game_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.CreateGameResponse.game_id)
}

// -------------------------------------------------------------------

// RegisterPlayerRequest

// string game_id = 1;
inline void RegisterPlayerRequest::clear_game_id() {
  _impl_.game_id_.ClearToEmpty();
}
inline const std::string& RegisterPlayerRequest::game_id() const {
  // @@protoc_insertion_point(field_get:bingo.RegisterPlayerRequest.game_id)
  return _internal_game_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterPlayerRequest::set_game_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.game_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.RegisterPlayerRequest.game_id)
}
inline std::string* RegisterPlayerRequest::mutable_game_id() {
  std::string* _s = _internal_mutable_game_id();
  // @@protoc_insertion_point(field_mutable:bingo.RegisterPlayerRequest.game_id)
  return _s;
}
inline const std::string& RegisterPlayerRequest::_internal_game_id() const {
  return _impl_.game_id_.Get();
}
inline void RegisterPlayerRequest::_internal_set_game_id(const std::string& value) {
  
  _impl_.game_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterPlayerRequest::_internal_mutable_game_id() {
  
  return _impl_.game_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterPlayerRequest::release_game_id() {
  // @@protoc_insertion_point(field_release:bingo.RegisterPlayerRequest.game_id)
  return _impl_.game_id_.Release();
}
inline void RegisterPlayerRequest::set_allocated_game_id(std::string* game_id) {
  if (game_id != nullptr) {
    
  } else {
    
  }
  _impl_.game_id_.SetAllocated(game_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_id_.IsDefault()) {
    _impl_.game_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.RegisterPlayerRequest.game_id)
}

// string player_name = 2;
inline void RegisterPlayerRequest::clear_player_name() {
  _impl_.player_name_.ClearToEmpty();
}
inline const std::string& RegisterPlayerRequest::player_name() const {
  // @@protoc_insertion_point(field_get:bingo.RegisterPlayerRequest.player_name)
  return _internal_player_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterPlayerRequest::set_player_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.RegisterPlayerRequest.player_name)
}
inline std::string* RegisterPlayerRequest::mutable_player_name() {
  std::string* _s = _internal_mutable_player_name();
  // @@protoc_insertion_point(field_mutable:bingo.RegisterPlayerRequest.player_name)
  return _s;
}
inline const std::string& RegisterPlayerRequest::_internal_player_name() const {
  return _impl_.player_name_.Get();
}
inline void RegisterPlayerRequest::_internal_set_player_name(const std::string& value) {
  
  _impl_.player_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterPlayerRequest::_internal_mutable_player_name() {
  
  return _impl_.player_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterPlayerRequest::release_player_name() {
  // @@protoc_insertion_point(field_release:bingo.RegisterPlayerRequest.player_name)
  return _impl_.player_name_.Release();
}
inline void RegisterPlayerRequest::set_allocated_player_name(std::string* player_name) {
  if (player_name != nullptr) {
    
  } else {
    
  }
  _impl_.player_name_.SetAllocated(player_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_name_.IsDefault()) {
    _impl_.player_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.RegisterPlayerRequest.player_name)
}

// -------------------------------------------------------------------

// RegisterPlayerResponse

// string player_id = 1;
inline void RegisterPlayerResponse::clear_player_id() {
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& RegisterPlayerResponse::player_id() const {
  // @@protoc_insertion_point(field_get:bingo.RegisterPlayerResponse.player_id)
  return _internal_player_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterPlayerResponse::set_player_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.RegisterPlayerResponse.player_id)
}
inline std::string* RegisterPlayerResponse::mutable_player_id() {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:bingo.RegisterPlayerResponse.player_id)
  return _s;
}
inline const std::string& RegisterPlayerResponse::_internal_player_id() const {
  return _impl_.player_id_.Get();
}
inline void RegisterPlayerResponse::_internal_set_player_id(const std::string& value) {
  
  _impl_.player_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterPlayerResponse::_internal_mutable_player_id() {
  
  return _impl_.player_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterPlayerResponse::release_player_id() {
  // @@protoc_insertion_point(field_release:bingo.RegisterPlayerResponse.player_id)
  return _impl_.player_id_.Release();
}
inline void RegisterPlayerResponse::set_allocated_player_id(std::string* player_id) {
  if (player_id != nullptr) {
    
  } else {
    
  }
  _impl_.player_id_.SetAllocated(player_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.RegisterPlayerResponse.player_id)
}

// repeated int32 card_numbers = 2;
inline int RegisterPlayerResponse::_internal_card_numbers_size() const {
  return _impl_.card_numbers_.size();
}
inline int RegisterPlayerResponse::card_numbers_size() const {
  return _internal_card_numbers_size();
}
inline void RegisterPlayerResponse::clear_card_numbers() {
  _impl_.card_numbers_.Clear();
}
inline int32_t RegisterPlayerResponse::_internal_card_numbers(int index) const {
  return _impl_.card_numbers_.Get(index);
}
inline int32_t RegisterPlayerResponse::card_numbers(int index) const {
  // @@protoc_insertion_point(field_get:bingo.RegisterPlayerResponse.card_numbers)
  return _internal_card_numbers(index);
}
inline void RegisterPlayerResponse::set_card_numbers(int index, int32_t value) {
  _impl_.card_numbers_.Set(index, value);
  // @@protoc_insertion_point(field_set:bingo.RegisterPlayerResponse.card_numbers)
}
inline void RegisterPlayerResponse::_internal_add_card_numbers(int32_t value) {
  _impl_.card_numbers_.Add(value);
}
inline void RegisterPlayerResponse::add_card_numbers(int32_t value) {
  _internal_add_card_numbers(value);
  // @@protoc_insertion_point(field_add:bingo.RegisterPlayerResponse.card_numbers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RegisterPlayerResponse::_internal_card_numbers() const {
  return _impl_.card_numbers_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RegisterPlayerResponse::card_numbers() const {
  // @@protoc_insertion_point(field_list:bingo.RegisterPlayerResponse.card_numbers)
  return _internal_card_numbers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RegisterPlayerResponse::_internal_mutable_card_numbers() {
  return &_impl_.card_numbers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RegisterPlayerResponse::mutable_card_numbers() {
  // @@protoc_insertion_point(field_mutable_list:bingo.RegisterPlayerResponse.card_numbers)
  return _internal_mutable_card_numbers();
}

// bool success = 3;
inline void RegisterPlayerResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool RegisterPlayerResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool RegisterPlayerResponse::success() const {
  // @@protoc_insertion_point(field_get:bingo.RegisterPlayerResponse.success)
  return _internal_success();
}
inline void RegisterPlayerResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void RegisterPlayerResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:bingo.RegisterPlayerResponse.success)
}

// -------------------------------------------------------------------

// DrawNumberRequest

// string game_id = 1;
inline void DrawNumberRequest::clear_game_id() {
  _impl_.game_id_.ClearToEmpty();
}
inline const std::string& DrawNumberRequest::game_id() const {
  // @@protoc_insertion_point(field_get:bingo.DrawNumberRequest.game_id)
  return _internal_game_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DrawNumberRequest::set_game_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.game_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.DrawNumberRequest.game_id)
}
inline std::string* DrawNumberRequest::mutable_game_id() {
  std::string* _s = _internal_mutable_game_id();
  // @@protoc_insertion_point(field_mutable:bingo.DrawNumberRequest.game_id)
  return _s;
}
inline const std::string& DrawNumberRequest::_internal_game_id() const {
  return _impl_.game_id_.Get();
}
inline void DrawNumberRequest::_internal_set_game_id(const std::string& value) {
  
  _impl_.game_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DrawNumberRequest::_internal_mutable_game_id() {
  
  return _impl_.game_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DrawNumberRequest::release_game_id() {
  // @@protoc_insertion_point(field_release:bingo.DrawNumberRequest.game_id)
  return _impl_.game_id_.Release();
}
inline void DrawNumberRequest::set_allocated_game_id(std::string* game_id) {
  if (game_id != nullptr) {
    
  } else {
    
  }
  _impl_.game_id_.SetAllocated(game_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_id_.IsDefault()) {
    _impl_.game_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.DrawNumberRequest.game_id)
}

// -------------------------------------------------------------------

// DrawNumberResponse

// int32 number = 1;
inline void DrawNumberResponse::clear_number() {
  _impl_.number_ = 0;
}
inline int32_t DrawNumberResponse::_internal_number() const {
  return _impl_.number_;
}
inline int32_t DrawNumberResponse::number() const {
  // @@protoc_insertion_point(field_get:bingo.DrawNumberResponse.number)
  return _internal_number();
}
inline void DrawNumberResponse::_internal_set_number(int32_t value) {
  
  _impl_.number_ = value;
}
inline void DrawNumberResponse::set_number(int32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:bingo.DrawNumberResponse.number)
}

// bool success = 2;
inline void DrawNumberResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool DrawNumberResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool DrawNumberResponse::success() const {
  // @@protoc_insertion_point(field_get:bingo.DrawNumberResponse.success)
  return _internal_success();
}
inline void DrawNumberResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void DrawNumberResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:bingo.DrawNumberResponse.success)
}

// -------------------------------------------------------------------

// MarkNumberRequest

// string game_id = 1;
inline void MarkNumberRequest::clear_game_id() {
  _impl_.game_id_.ClearToEmpty();
}
inline const std::string& MarkNumberRequest::game_id() const {
  // @@protoc_insertion_point(field_get:bingo.MarkNumberRequest.game_id)
  return _internal_game_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkNumberRequest::set_game_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.game_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.MarkNumberRequest.game_id)
}
inline std::string* MarkNumberRequest::mutable_game_id() {
  std::string* _s = _internal_mutable_game_id();
  // @@protoc_insertion_point(field_mutable:bingo.MarkNumberRequest.game_id)
  return _s;
}
inline const std::string& MarkNumberRequest::_internal_game_id() const {
  return _impl_.game_id_.Get();
}
inline void MarkNumberRequest::_internal_set_game_id(const std::string& value) {
  
  _impl_.game_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkNumberRequest::_internal_mutable_game_id() {
  
  return _impl_.game_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkNumberRequest::release_game_id() {
  // @@protoc_insertion_point(field_release:bingo.MarkNumberRequest.game_id)
  return _impl_.game_id_.Release();
}
inline void MarkNumberRequest::set_allocated_game_id(std::string* game_id) {
  if (game_id != nullptr) {
    
  } else {
    
  }
  _impl_.game_id_.SetAllocated(game_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_id_.IsDefault()) {
    _impl_.game_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.MarkNumberRequest.game_id)
}

// string player_id = 2;
inline void MarkNumberRequest::clear_player_id() {
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& MarkNumberRequest::player_id() const {
  // @@protoc_insertion_point(field_get:bingo.MarkNumberRequest.player_id)
  return _internal_player_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkNumberRequest::set_player_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.MarkNumberRequest.player_id)
}
inline std::string* MarkNumberRequest::mutable_player_id() {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:bingo.MarkNumberRequest.player_id)
  return _s;
}
inline const std::string& MarkNumberRequest::_internal_player_id() const {
  return _impl_.player_id_.Get();
}
inline void MarkNumberRequest::_internal_set_player_id(const std::string& value) {
  
  _impl_.player_id_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkNumberRequest::_internal_mutable_player_id() {
  
  return _impl_.player_id_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkNumberRequest::release_player_id() {
  // @@protoc_insertion_point(field_release:bingo.MarkNumberRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void MarkNumberRequest::set_allocated_player_id(std::string* player_id) {
  if (player_id != nullptr) {
    
  } else {
    
  }
  _impl_.player_id_.SetAllocated(player_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.MarkNumberRequest.player_id)
}

// int32 number = 3;
inline void MarkNumberRequest::clear_number() {
  _impl_.number_ = 0;
}
inline int32_t MarkNumberRequest::_internal_number() const {
  return _impl_.number_;
}
inline int32_t MarkNumberRequest::number() const {
  // @@protoc_insertion_point(field_get:bingo.MarkNumberRequest.number)
  return _internal_number();
}
inline void MarkNumberRequest::_internal_set_number(int32_t value) {
  
  _impl_.number_ = value;
}
inline void MarkNumberRequest::set_number(int32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:bingo.MarkNumberRequest.number)
}

// -------------------------------------------------------------------

// MarkNumberResponse

// bool success = 1;
inline void MarkNumberResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool MarkNumberResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool MarkNumberResponse::success() const {
  // @@protoc_insertion_point(field_get:bingo.MarkNumberResponse.success)
  return _internal_success();
}
inline void MarkNumberResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void MarkNumberResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:bingo.MarkNumberResponse.success)
}

// -------------------------------------------------------------------

// CheckBingoRequest

// string game_id = 1;
inline void CheckBingoRequest::clear_game_id() {
  _impl_.game_id_.ClearToEmpty();
}
inline const std::string& CheckBingoRequest::game_id() const {
  // @@protoc_insertion_point(field_get:bingo.CheckBingoRequest.game_id)
  return _internal_game_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckBingoRequest::set_game_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.game_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.CheckBingoRequest.game_id)
}
inline std::string* CheckBingoRequest::mutable_game_id() {
  std::string* _s = _internal_mutable_game_id();
  // @@protoc_insertion_point(field_mutable:bingo.CheckBingoRequest.game_id)
  return _s;
}
inline const std::string& CheckBingoRequest::_internal_game_id() const {
  return _impl_.game_id_.Get();
}
inline void CheckBingoRequest::_internal_set_game_id(const std::string& value) {
  
  _impl_.game_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckBingoRequest::_internal_mutable_game_id() {
  
  return _impl_.game_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckBingoRequest::release_game_id() {
  // @@protoc_insertion_point(field_release:bingo.CheckBingoRequest.game_id)
  return _impl_.game_id_.Release();
}
inline void CheckBingoRequest::set_allocated_game_id(std::string* game_id) {
  if (game_id != nullptr) {
    
  } else {
    
  }
  _impl_.game_id_.SetAllocated(game_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.game_id_.IsDefault()) {
    _impl_.game_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.CheckBingoRequest.game_id)
}

// string player_id = 2;
inline void CheckBingoRequest::clear_player_id() {
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& CheckBingoRequest::player_id() const {
  // @@protoc_insertion_point(field_get:bingo.CheckBingoRequest.player_id)
  return _internal_player_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CheckBingoRequest::set_player_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.CheckBingoRequest.player_id)
}
inline std::string* CheckBingoRequest::mutable_player_id() {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:bingo.CheckBingoRequest.player_id)
  return _s;
}
inline const std::string& CheckBingoRequest::_internal_player_id() const {
  return _impl_.player_id_.Get();
}
inline void CheckBingoRequest::_internal_set_player_id(const std::string& value) {
  
  _impl_.player_id_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckBingoRequest::_internal_mutable_player_id() {
  
  return _impl_.player_id_.Mutable(GetArenaForAllocation());
}
inline std::string* CheckBingoRequest::release_player_id() {
  // @@protoc_insertion_point(field_release:bingo.CheckBingoRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void CheckBingoRequest::set_allocated_player_id(std::string* player_id) {
  if (player_id != nullptr) {
    
  } else {
    
  }
  _impl_.player_id_.SetAllocated(player_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.CheckBingoRequest.player_id)
}

// -------------------------------------------------------------------

// CheckBingoResponse

// bool bingo = 1;
inline void CheckBingoResponse::clear_bingo() {
  _impl_.bingo_ = false;
}
inline bool CheckBingoResponse::_internal_bingo() const {
  return _impl_.bingo_;
}
inline bool CheckBingoResponse::bingo() const {
  // @@protoc_insertion_point(field_get:bingo.CheckBingoResponse.bingo)
  return _internal_bingo();
}
inline void CheckBingoResponse::_internal_set_bingo(bool value) {
  
  _impl_.bingo_ = value;
}
inline void CheckBingoResponse::set_bingo(bool value) {
  _internal_set_bingo(value);
  // @@protoc_insertion_point(field_set:bingo.CheckBingoResponse.bingo)
}

// -------------------------------------------------------------------

// ValidateNumberRequest

// string player_id = 1;
inline void ValidateNumberRequest::clear_player_id() {
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& ValidateNumberRequest::player_id() const {
  // @@protoc_insertion_point(field_get:bingo.ValidateNumberRequest.player_id)
  return _internal_player_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateNumberRequest::set_player_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.ValidateNumberRequest.player_id)
}
inline std::string* ValidateNumberRequest::mutable_player_id() {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:bingo.ValidateNumberRequest.player_id)
  return _s;
}
inline const std::string& ValidateNumberRequest::_internal_player_id() const {
  return _impl_.player_id_.Get();
}
inline void ValidateNumberRequest::_internal_set_player_id(const std::string& value) {
  
  _impl_.player_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidateNumberRequest::_internal_mutable_player_id() {
  
  return _impl_.player_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ValidateNumberRequest::release_player_id() {
  // @@protoc_insertion_point(field_release:bingo.ValidateNumberRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void ValidateNumberRequest::set_allocated_player_id(std::string* player_id) {
  if (player_id != nullptr) {
    
  } else {
    
  }
  _impl_.player_id_.SetAllocated(player_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.ValidateNumberRequest.player_id)
}

// int32 number = 2;
inline void ValidateNumberRequest::clear_number() {
  _impl_.number_ = 0;
}
inline int32_t ValidateNumberRequest::_internal_number() const {
  return _impl_.number_;
}
inline int32_t ValidateNumberRequest::number() const {
  // @@protoc_insertion_point(field_get:bingo.ValidateNumberRequest.number)
  return _internal_number();
}
inline void ValidateNumberRequest::_internal_set_number(int32_t value) {
  
  _impl_.number_ = value;
}
inline void ValidateNumberRequest::set_number(int32_t value) {
  _internal_set_number(value);
  // @@protoc_insertion_point(field_set:bingo.ValidateNumberRequest.number)
}

// -------------------------------------------------------------------

// ValidateNumberResponse

// bool success = 1;
inline void ValidateNumberResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool ValidateNumberResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool ValidateNumberResponse::success() const {
  // @@protoc_insertion_point(field_get:bingo.ValidateNumberResponse.success)
  return _internal_success();
}
inline void ValidateNumberResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ValidateNumberResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:bingo.ValidateNumberResponse.success)
}

// -------------------------------------------------------------------

// ValidateBingoRequest

// string player_id = 1;
inline void ValidateBingoRequest::clear_player_id() {
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& ValidateBingoRequest::player_id() const {
  // @@protoc_insertion_point(field_get:bingo.ValidateBingoRequest.player_id)
  return _internal_player_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ValidateBingoRequest::set_player_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.ValidateBingoRequest.player_id)
}
inline std::string* ValidateBingoRequest::mutable_player_id() {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:bingo.ValidateBingoRequest.player_id)
  return _s;
}
inline const std::string& ValidateBingoRequest::_internal_player_id() const {
  return _impl_.player_id_.Get();
}
inline void ValidateBingoRequest::_internal_set_player_id(const std::string& value) {
  
  _impl_.player_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ValidateBingoRequest::_internal_mutable_player_id() {
  
  return _impl_.player_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ValidateBingoRequest::release_player_id() {
  // @@protoc_insertion_point(field_release:bingo.ValidateBingoRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void ValidateBingoRequest::set_allocated_player_id(std::string* player_id) {
  if (player_id != nullptr) {
    
  } else {
    
  }
  _impl_.player_id_.SetAllocated(player_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.ValidateBingoRequest.player_id)
}

// repeated int32 numbers = 2;
inline int ValidateBingoRequest::_internal_numbers_size() const {
  return _impl_.numbers_.size();
}
inline int ValidateBingoRequest::numbers_size() const {
  return _internal_numbers_size();
}
inline void ValidateBingoRequest::clear_numbers() {
  _impl_.numbers_.Clear();
}
inline int32_t ValidateBingoRequest::_internal_numbers(int index) const {
  return _impl_.numbers_.Get(index);
}
inline int32_t ValidateBingoRequest::numbers(int index) const {
  // @@protoc_insertion_point(field_get:bingo.ValidateBingoRequest.numbers)
  return _internal_numbers(index);
}
inline void ValidateBingoRequest::set_numbers(int index, int32_t value) {
  _impl_.numbers_.Set(index, value);
  // @@protoc_insertion_point(field_set:bingo.ValidateBingoRequest.numbers)
}
inline void ValidateBingoRequest::_internal_add_numbers(int32_t value) {
  _impl_.numbers_.Add(value);
}
inline void ValidateBingoRequest::add_numbers(int32_t value) {
  _internal_add_numbers(value);
  // @@protoc_insertion_point(field_add:bingo.ValidateBingoRequest.numbers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ValidateBingoRequest::_internal_numbers() const {
  return _impl_.numbers_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ValidateBingoRequest::numbers() const {
  // @@protoc_insertion_point(field_list:bingo.ValidateBingoRequest.numbers)
  return _internal_numbers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ValidateBingoRequest::_internal_mutable_numbers() {
  return &_impl_.numbers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ValidateBingoRequest::mutable_numbers() {
  // @@protoc_insertion_point(field_mutable_list:bingo.ValidateBingoRequest.numbers)
  return _internal_mutable_numbers();
}

// -------------------------------------------------------------------

// ValidateBingoResponse

// bool bingo = 1;
inline void ValidateBingoResponse::clear_bingo() {
  _impl_.bingo_ = false;
}
inline bool ValidateBingoResponse::_internal_bingo() const {
  return _impl_.bingo_;
}
inline bool ValidateBingoResponse::bingo() const {
  // @@protoc_insertion_point(field_get:bingo.ValidateBingoResponse.bingo)
  return _internal_bingo();
}
inline void ValidateBingoResponse::_internal_set_bingo(bool value) {
  
  _impl_.bingo_ = value;
}
inline void ValidateBingoResponse::set_bingo(bool value) {
  _internal_set_bingo(value);
  // @@protoc_insertion_point(field_set:bingo.ValidateBingoResponse.bingo)
}

// -------------------------------------------------------------------

// GetCardRequest

// string player_id = 1;
inline void GetCardRequest::clear_player_id() {
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& GetCardRequest::player_id() const {
  // @@protoc_insertion_point(field_get:bingo.GetCardRequest.player_id)
  return _internal_player_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCardRequest::set_player_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.GetCardRequest.player_id)
}
inline std::string* GetCardRequest::mutable_player_id() {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:bingo.GetCardRequest.player_id)
  return _s;
}
inline const std::string& GetCardRequest::_internal_player_id() const {
  return _impl_.player_id_.Get();
}
inline void GetCardRequest::_internal_set_player_id(const std::string& value) {
  
  _impl_.player_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCardRequest::_internal_mutable_player_id() {
  
  return _impl_.player_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetCardRequest::release_player_id() {
  // @@protoc_insertion_point(field_release:bingo.GetCardRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void GetCardRequest::set_allocated_player_id(std::string* player_id) {
  if (player_id != nullptr) {
    
  } else {
    
  }
  _impl_.player_id_.SetAllocated(player_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.GetCardRequest.player_id)
}

// -------------------------------------------------------------------

// GetCardResponse

// repeated int32 card_numbers = 1;
inline int GetCardResponse::_internal_card_numbers_size() const {
  return _impl_.card_numbers_.size();
}
inline int GetCardResponse::card_numbers_size() const {
  return _internal_card_numbers_size();
}
inline void GetCardResponse::clear_card_numbers() {
  _impl_.card_numbers_.Clear();
}
inline int32_t GetCardResponse::_internal_card_numbers(int index) const {
  return _impl_.card_numbers_.Get(index);
}
inline int32_t GetCardResponse::card_numbers(int index) const {
  // @@protoc_insertion_point(field_get:bingo.GetCardResponse.card_numbers)
  return _internal_card_numbers(index);
}
inline void GetCardResponse::set_card_numbers(int index, int32_t value) {
  _impl_.card_numbers_.Set(index, value);
  // @@protoc_insertion_point(field_set:bingo.GetCardResponse.card_numbers)
}
inline void GetCardResponse::_internal_add_card_numbers(int32_t value) {
  _impl_.card_numbers_.Add(value);
}
inline void GetCardResponse::add_card_numbers(int32_t value) {
  _internal_add_card_numbers(value);
  // @@protoc_insertion_point(field_add:bingo.GetCardResponse.card_numbers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetCardResponse::_internal_card_numbers() const {
  return _impl_.card_numbers_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
GetCardResponse::card_numbers() const {
  // @@protoc_insertion_point(field_list:bingo.GetCardResponse.card_numbers)
  return _internal_card_numbers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetCardResponse::_internal_mutable_card_numbers() {
  return &_impl_.card_numbers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
GetCardResponse::mutable_card_numbers() {
  // @@protoc_insertion_point(field_mutable_list:bingo.GetCardResponse.card_numbers)
  return _internal_mutable_card_numbers();
}

// -------------------------------------------------------------------

// RegisterCardRequest

// string player_id = 1;
inline void RegisterCardRequest::clear_player_id() {
  _impl_.player_id_.ClearToEmpty();
}
inline const std::string& RegisterCardRequest::player_id() const {
  // @@protoc_insertion_point(field_get:bingo.RegisterCardRequest.player_id)
  return _internal_player_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterCardRequest::set_player_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.player_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:bingo.RegisterCardRequest.player_id)
}
inline std::string* RegisterCardRequest::mutable_player_id() {
  std::string* _s = _internal_mutable_player_id();
  // @@protoc_insertion_point(field_mutable:bingo.RegisterCardRequest.player_id)
  return _s;
}
inline const std::string& RegisterCardRequest::_internal_player_id() const {
  return _impl_.player_id_.Get();
}
inline void RegisterCardRequest::_internal_set_player_id(const std::string& value) {
  
  _impl_.player_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterCardRequest::_internal_mutable_player_id() {
  
  return _impl_.player_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterCardRequest::release_player_id() {
  // @@protoc_insertion_point(field_release:bingo.RegisterCardRequest.player_id)
  return _impl_.player_id_.Release();
}
inline void RegisterCardRequest::set_allocated_player_id(std::string* player_id) {
  if (player_id != nullptr) {
    
  } else {
    
  }
  _impl_.player_id_.SetAllocated(player_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.player_id_.IsDefault()) {
    _impl_.player_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:bingo.RegisterCardRequest.player_id)
}

// repeated int32 card_numbers = 2;
inline int RegisterCardRequest::_internal_card_numbers_size() const {
  return _impl_.card_numbers_.size();
}
inline int RegisterCardRequest::card_numbers_size() const {
  return _internal_card_numbers_size();
}
inline void RegisterCardRequest::clear_card_numbers() {
  _impl_.card_numbers_.Clear();
}
inline int32_t RegisterCardRequest::_internal_card_numbers(int index) const {
  return _impl_.card_numbers_.Get(index);
}
inline int32_t RegisterCardRequest::card_numbers(int index) const {
  // @@protoc_insertion_point(field_get:bingo.RegisterCardRequest.card_numbers)
  return _internal_card_numbers(index);
}
inline void RegisterCardRequest::set_card_numbers(int index, int32_t value) {
  _impl_.card_numbers_.Set(index, value);
  // @@protoc_insertion_point(field_set:bingo.RegisterCardRequest.card_numbers)
}
inline void RegisterCardRequest::_internal_add_card_numbers(int32_t value) {
  _impl_.card_numbers_.Add(value);
}
inline void RegisterCardRequest::add_card_numbers(int32_t value) {
  _internal_add_card_numbers(value);
  // @@protoc_insertion_point(field_add:bingo.RegisterCardRequest.card_numbers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RegisterCardRequest::_internal_card_numbers() const {
  return _impl_.card_numbers_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
RegisterCardRequest::card_numbers() const {
  // @@protoc_insertion_point(field_list:bingo.RegisterCardRequest.card_numbers)
  return _internal_card_numbers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RegisterCardRequest::_internal_mutable_card_numbers() {
  return &_impl_.card_numbers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
RegisterCardRequest::mutable_card_numbers() {
  // @@protoc_insertion_point(field_mutable_list:bingo.RegisterCardRequest.card_numbers)
  return _internal_mutable_card_numbers();
}

// -------------------------------------------------------------------

// RegisterCardResponse

// bool success = 1;
inline void RegisterCardResponse::clear_success() {
  _impl_.success_ = false;
}
inline bool RegisterCardResponse::_internal_success() const {
  return _impl_.success_;
}
inline bool RegisterCardResponse::success() const {
  // @@protoc_insertion_point(field_get:bingo.RegisterCardResponse.success)
  return _internal_success();
}
inline void RegisterCardResponse::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void RegisterCardResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:bingo.RegisterCardResponse.success)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bingo

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_bingo_2eproto
